# Java基础

## 1、Java类加载过程

![img](Java基础.assets/2369895-3c984ab4469ec954.png)

**加载**：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口

**验证**：文件格式验证、元数据验证、字节码验证、符号引用验证,检查加载的class文件的正确性;
**准备**：给类中的静态变量分配内存空间并设置静态变量初始值(数据类型默认值)；
**解析**：虚拟机将常量池中的符号引用替换成直接应用的过程，**符号引用**用一组符号来描述所引用的目标，**直接引用**就是直接指向内存中的地址；
**初始化**：对静态变量和静态代码块执行初始化工作；

![è¿éåå¾çæè¿°](Java基础.assets/20170915085559178-1621049973049)

## 2、Java类卸载

卸载类即该类的对象被GC。

需要满足3个要求该类才会被卸载：

1. 该类的所有实例对象都已经被GC。
2. 该类对应的Class对象没有在其他地方被引用。
3. 加载该类的类加载器已经被回收。

## 3、Maven的作用

1. Maven可以统一管理所有的依赖jar包，不需要程序员再去寻找
2. 对第三方组件用到的共同jar包，Maven自动解决重复和冲突问题
3. Maven可以统一每个项目的构建过程，实现不同项目的兼容性管理

Maven查看依赖树命令：`mvn dependency:tree`



## 4、final 、 finally 、 finalize三个关键字的区别

1. final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
2. finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码放在finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
3. finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(), 回收垃圾。 



## 5、ReentrantLock实现原理

**ReentrantLock**是一把**可重入的排它锁**。多线程下，可以保证只有一个线程获取该锁，如果该线程已经获取锁，并且重新尝试获取该锁是可以成功获取的。主要用途就是为共享资源提供同步访问的作用。

使用例子：new 一个ReentrantLock 实例，然后调用**lock**方法获取锁，使用完毕调用unlock方法释放该锁。这样就保证lock 和 unlock 之间的代码块是同步访问的。如图所示：

```java
ReentrantLock lock = new ReentrantLock();
lock.lock();
try{
    //同步代码块
    
}finally{
    lock.unlock();
}
```

> 释放锁一定要放在try-catch的finally语句里，否则容易出现无法释放锁，导致其他线程一直阻塞无法获取该锁

**ReentrantLock**整个锁的实现都是通过委托给静态内部抽象类**Sync**实现。抽象类**Sync**分别又有**公平锁(FairSync)**和**非公平锁(NonfairSync)**的实现类。通过**ReentrantLock**构造函数参数来指定使用公平锁还是非公平锁。

- 多线程下保证只有一个线程获取到锁

  锁的实现都是委托给**Sync**静态类实现的，它继承了**AQS**类。AQS类中维护了一个同步状态int型变量**state**，默认值为0。当线程获取锁的时候，就通过**Unsafe**提供的CAS方法，修改state值为1，修改成功就获取该锁，修改失败就获取失败。

- 当锁已经被一个线程获取，其他线程获取锁失败时的处理方法

  当获取锁失败，AQS中提供了一个FIFO的等待队列。把获取失败的线程封装成一个节点，然后插入等待队列中，同时把该线程设置成阻塞状态。

- 当锁被释放时，通知其他线程继续竞争锁的实现方法

  当锁释放后，唤醒等待队列中的第一个线程，然后该线程重新通过CAS来竞争锁。如果获取成功，则从等待队列中删除，如果获取失败，继续保持在等待队列中，等待下次唤醒。

**公平锁原理：**AQS维护了一个先进先出的等待队列，只要等待队列中有等待的线程，则新来的尝试获取锁的线程都插入等待队列中。这样保证之前的等待队列先获取该锁。

**非公平锁原理：**当锁被释放后，还未进去等待队列的线程和在等待队列中唤醒的线程可同时竞争获取该锁。这样刚来竞争的线程可能就获取到锁，而等了很久的线程依然没有获取。这就是不公平的地方。这种方式性能好，刚来的线程少了阻塞和唤醒。

## 6、公平锁和非公平锁，如何实现

**公平锁/非公平锁：**当多个线程获取锁的时候，按照规则排队等待即为公平锁，不按照规则排队的即为非公平锁。

**ReentrantLock**通过传入的参数来决定是否使用公平锁，参数为true公平锁，默认使用非公平锁。**Synchronized**是一个非公平锁。

**ReentrantLock实现非公平锁：**线程争夺锁的过程中，会先进行一次CAS尝试获取锁，如果失败，进入`acquire(1)`函数，进行一次`tryAcquire`再次尝试获取锁。如果再次失败，就通过`addWaiter`将当前线程封装成node节点加入到Sync队列，这时该线程只能等前面的线程执行完再去执行。

**ReentrantLock实现公平锁：**当线程获取锁的时候，会先判断Sync队列中是否有在等待获取资源的线程。如果没有，就尝试获取锁。如果有，就通过`addWaiter`将当前线程封装成node节点加入到Sync队列中



## 7、synchronized和Lock的区别

1. 首先synchronized是java内置关键字在**jvm层面**，适合少量代码加锁。Lock是个java类，提供的是一个**API层面**的锁，适合大量代码加锁。
2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁，并且可以主动尝试去获取锁。
3. synchronized会**自动释放锁**(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock**需在finally中手工释放锁**（unlock()方法释放锁），否则容易造成线程死锁。
4. 用synchronized是不可中断类型的锁，除非加锁的代码中出现异常或者正常执行完成，而Lock锁可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。
5. synchronized的锁**可重入、不可中断、非公平**，而Lock锁**可重入、可中断、可公平**（两者皆可）
6. synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢。

# MySQL

## 1、MySQL索引为什么使用B+树

- 使用二叉搜索树：可能退化成链表，会导致查找的时间复杂度为O(n)
- 使用AVL树：可以有效预防二叉树退化为链表，但是为了追求绝对的平衡，需要进行一些旋转，是十分耗时的操作
- 使用红黑树：红黑树不追求子树的高度差不超过1，相较于AVL树更好一些，但是每个节点只能存储一个数据，数据量较大时，也会导致查找时间复杂度较大
- 使用B树：每个节点都是索引，节点下方存放着索引对应的数据。查找单个数据时，若命中索引，则所需时间很短，若数据位于叶子节点，则所需时间比较长，多次取出数据的时间不稳定。进行`select *`操作的时候，需要依次从上往下遍历，然后取出每个节点对应的数据，过程很耗时
- 使用B+树：每个非叶子节点只存储索引，所有的数据都存放在叶子节点上，并且每个区之间的叶子节点都有指针连接，形成一个链表。查找单个数据时，都需要找到叶子节点，多次取出数据的时间是稳定的。进行`select *`操作的时候，只需要找到第一个叶子节点，然后顺着指针向后遍历即可，不需要回到上面再去查找了。





# Redis

## 1、缓存穿透

缓存穿透就是大量请求的**key不在缓存中**，导致请求直接到了数据库上，没有经过缓存这一层。

解决方案：首先可以做好参数校验，不合法的参数请求直接抛出异常信息返回给客户端。最常见的则是选择使用**布隆过滤器**。它将所有可能存在的数据哈希到一个足够大的位数组(Bitmap)中，一个一定不存在的数据会被拦截掉。



## 2、缓存击穿

缓存击穿就是对应的**key是存在的**，但在Redis中过期。此时如果有大量的并发请求过来，就会从数据库中获取数据，可能会把后端数据库压垮。

解决方案：

1. **加互斥锁**：在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他线程拿不到锁就阻塞等待。等到第一个线程将数据写入缓存之后，直接走缓存。锁可以用Redis的**分布式锁**，也可以用**JVM锁**。
2. **热点数据不过期**：直接将缓存设置为不过期，然后由定时任务去异步加载数据，更新缓存。



## 3、缓存雪崩

缓存雪崩就是缓存中大量的热点key设置了相同的过期时间，导致缓存在同一时刻全部失效。造成瞬时数据库请求量大、压力骤增。

解决方案：

1. **设置不同的失效时间**：给缓存设一个随机过期时间，使每个key的过期时间分布开，不会在同一时刻失效。
2. **热点数据不过期**



## 4、Redis的rehash

Redis的rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的，redis会维护维持一个索引计数器变量rehashidx来表示rehash的进度。

**详细步骤如下：**

1. **为`ht[1]`分配空间，让字典同时持有`ht[0]`和`ht[1]`两个哈希表**
2. **将`rehashindex`的值设置为`0`，表示rehash工作正式开始**
3. **在rehash期间，每次对字典执行增删改查操作时，程序除了执行指定的操作以外，还会顺带将`ht[0]`哈希表在`rehashindex`索引上的所有键值对rehash到`ht[1]`，当rehash工作完成以后，`rehashindex`的值`+1`**
4. **随着字典操作的不断执行，最终会在某一时间段上`ht[0]`的所有键值对都会被rehash到`ht[1]`，这时将`rehashindex`的值设置为`-1`，表示rehash操作结束**



这种渐进式的 rehash 避免了集中式rehash带来的庞大计算量和内存操作，但是需要注意的是redis在进行rehash的时候，正常的访问请求可能需要做多要访问两次hashtable（ht[0]， ht[1]），例如键值被rehash到新ht1，则需要先访问ht0，如果ht0中找不到，则去ht1中找。



## 5、Redis的内存问题

查看Redis最大占用内存：redis.conf文件中 查看maxmemory参数设置的大小，在64位机器中默认无限制

一般生产上如何配置：一般推荐Redis设置内存为最大物理内存的四分之三

如何修改Redis内存设置：通过修改文件配置 `maxmemory 1048576000`：设置内存为100M

​											通过命令来修改 `config set maxmemroy 1048576000`

通过命令查看Redis内存使用情况：`info memory`

Redis内存打满后会报OOM错误 



# 计算机网络

## 1、get和post的区别

GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间用&相连。POST方法是把提交的数据放在HTTP的Body中。

GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。

GET方式提交数据，会带来安全问题。



## 2、Cookie和Session的区别

Cookie和Session都是用来跟踪浏览器用户身份的会话方式

Cookie存放在客户端，一般用来保存用户信息。Session数据保存在服务器端，主要通是通过服务端记录用户的状态。相对来说Session安全性更高